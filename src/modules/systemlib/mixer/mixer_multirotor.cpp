
/**
 * @file mixer_multirotor.cpp
 *
 * Multi-rotor mixers.
 */
#include <nuttx/config.h>
#include <sys/types.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>
#include <math.h>

#include <nuttx/float.h>

#include <iofirmware/protocol.h>

#include "mixer.h"

// This file is generated by the multi_tables script which is invoked during the build process
#include "mixer_multirotor.generated.h" //这个文件是multi_table脚本生成的，这个脚本是在编译过程中执行的

#define debug(fmt, args...)	do { } while(0)
//#define debug(fmt, args...)	do { printf("[mixer] " fmt "\n", ##args); } while(0)
//#include <debug.h>
//#define debug(fmt, args...)	lowsyslog(fmt "\n", ##args)

/*
 * Clockwise: 1  顺时针
 * Counter-clockwise: -1 逆时针
 */

namespace  //全局名字空间
{

float constrain(float val, float min, float max)  //限制在范围内
{
	return (val < min) ? min : ((val > max) ? max : val);
}

} // anonymous namespace

MultirotorMixer::MultirotorMixer(ControlCallback control_cb,   //构造函数
				 uintptr_t cb_handle,
				 MultirotorGeometry geometry,
				 float roll_scale,
				 float pitch_scale,
				 float yaw_scale,
				 float idle_speed) :
	Mixer(control_cb, cb_handle),  //回调函数，回调函数句柄
	_roll_scale(roll_scale),  //缩放因子
	_pitch_scale(pitch_scale),
	_yaw_scale(yaw_scale),
	_idle_speed(-1.0f + idle_speed * 2.0f),	/* shift to output range here to avoid runtime calculation */  //转换到输出量程，避免执行计算时间
	_limits_pub(),  //发布限制主题
	_rotor_count(_config_rotor_count[(MultirotorGeometryUnderlyingType)geometry]),  //马达数量
	_rotors(_config_index[(MultirotorGeometryUnderlyingType)geometry])  //配置索引
{
}

MultirotorMixer::~MultirotorMixer() //析构函数
{
}

MultirotorMixer *
MultirotorMixer::from_text(Mixer::ControlCallback control_cb, uintptr_t cb_handle, const char *buf, unsigned &buflen)  //mixer_group.cpp中调用
{
	MultirotorGeometry geometry;  //枚举在mixer_multirotor.generated.h文件中，由python脚本执行
	char geomname[8];  //几何结构名称
	int s[4];
	int used;

	/* enforce that the mixer ends with space or a new line */ //强制混控器以空格或者下一行为结尾
	for (int i = buflen - 1; i >= 0; i--) {//从最后一行开始扫描
		if (buf[i] == '\0') {  //如果为结束付，向前进一位
			continue;
		}

		/* require a space or newline at the end of the buffer, fail on printable chars */  //需要一个空格或者新的一行在缓冲区结尾，如果是可打印字符则失败
		if (buf[i] == ' ' || buf[i] == '\n' || buf[i] == '\r') { //如果为空格/结尾或者换行
			/* found a line ending or space, so no split symbols / numbers. good. */
			break;

		} else {
			debug("simple parser rejected: No newline / space at end of buf. (#%d/%d: 0x%02x)", i, buflen - 1, buf[i]);
			return nullptr;
		}

	}

	if (sscanf(buf, "R: %s %d %d %d %d%n", geomname, &s[0], &s[1], &s[2], &s[3], &used) != 5) { //扫描缓冲区，返回5个anci字符
		debug("multirotor parse failed on '%s'", buf);  //多旋翼参数解析失败
		return nullptr;
	}

	if (used > (int)buflen) {  //如果使用的大于缓冲区数量
		debug("OVERFLOW: multirotor spec used %d of %u", used, buflen);  //溢出
		return nullptr;
	}

	buf = skipline(buf, buflen);  //跳过行

	if (buf == nullptr) { //如果为空，没有行结尾，行不完整
		debug("no line ending, line is incomplete");
		return nullptr;
	}

	debug("remaining in buf: %d, first char: %c", buflen, buf[0]);

	if (!strcmp(geomname, "4+")) {  //判断几何结构，解析代码
		geometry = MultirotorGeometry::QUAD_PLUS;

	} else if (!strcmp(geomname, "4x")) {
		geometry = MultirotorGeometry::QUAD_X;

	} else if (!strcmp(geomname, "4h")) {
		geometry = MultirotorGeometry::QUAD_H;

	} else if (!strcmp(geomname, "4v")) {
		geometry = MultirotorGeometry::QUAD_V;

	} else if (!strcmp(geomname, "4w")) {
		geometry = MultirotorGeometry::QUAD_WIDE;

	} else if (!strcmp(geomname, "4dc")) {
		geometry = MultirotorGeometry::QUAD_DEADCAT;

	} else if (!strcmp(geomname, "6+")) {
		geometry = MultirotorGeometry::HEX_PLUS;

	} else if (!strcmp(geomname, "6x")) {
		geometry = MultirotorGeometry::HEX_X;

	} else if (!strcmp(geomname, "6c")) {
		geometry = MultirotorGeometry::HEX_COX;

	} else if (!strcmp(geomname, "8+")) {
		geometry = MultirotorGeometry::OCTA_PLUS;

	} else if (!strcmp(geomname, "8x")) {
		geometry = MultirotorGeometry::OCTA_X;

	} else if (!strcmp(geomname, "8c")) {
		geometry = MultirotorGeometry::OCTA_COX;

#if 0

	} else if (!strcmp(geomname, "8cw")) {
		geometry = MultirotorGeometry::OCTA_COX_WIDE;
#endif

	} else if (!strcmp(geomname, "2-")) {
		geometry = MultirotorGeometry::TWIN_ENGINE;

	} else if (!strcmp(geomname, "3y")) {
		geometry = MultirotorGeometry::TRI_Y;

	} else {
		debug("unrecognised geometry '%s'", geomname);
		return nullptr;
	}

	debug("adding multirotor mixer '%s'", geomname);

	return new MultirotorMixer(  //返回新类
		       control_cb,   //回调函数
		       cb_handle,    //回调函数句柄
		       geometry,     //几个结构
		       s[0] / 10000.0f,   //roll缩放因子
		       s[1] / 10000.0f,   //pitch缩放因子
		       s[2] / 10000.0f,   //yaw缩放因子
		       s[3] / 10000.0f);  //死区
}

unsigned
MultirotorMixer::mix(float *outputs, unsigned space, uint16_t *status_reg)  //混合
{
	/* Summary of mixing strategy:  混控策略摘要
	1) mix roll, pitch and thrust without yaw.  混合横滚，俯仰和推力，没有偏航
	2) if some outputs violate range [0,1] then try to shift all outputs to minimize violation ->  如果一些输出违反了【0,1】的范围，尝试转换所有的输出到最小的违反
		increase or decrease total thrust (boost). The total increase or decrease of thrust is limited  增加或者减小全部的推力。全部的推力增加或者减小被限制了
		(max_thrust_diff). If after the shift some outputs still violate the bounds then scale roll & pitch.  如果在转换一些输出后还是超出了边界，就缩放横滚和俯仰轴
		In case there is violation at the lower and upper bound then try to shift such that violation is equal
		on both sides.  如果违反的在最大或者最小的边界，就将其等于边界
	3) mix in yaw and scale if it leads to limit violation. 混合到偏航轴。如果这样导致违反极限，就缩放它
	4) scale all outputs to range [idle_speed,1]  缩放所有的输出到范围内
	*/

	float		roll    = constrain(get_control(0, 0) * _roll_scale, -1.0f, 1.0f);  //缩放并限制到-1,1
	float		pitch   = constrain(get_control(0, 1) * _pitch_scale, -1.0f, 1.0f);
	float		yaw     = constrain(get_control(0, 2) * _yaw_scale, -1.0f, 1.0f);
	float		thrust  = constrain(get_control(0, 3), 0.0f, 1.0f);  //推力
	float		min_out = 0.0f;
	float		max_out = 0.0f;

	// clean register for saturation status flags 清除饱和状态标志
	if (status_reg != NULL) {
		(*status_reg) = 0;
	}

	// thrust boost parameters  推力促进参数
	float thrust_increase_factor = 1.5f;  //推力每次增加的步进值
	float thrust_decrease_factor = 0.6f;  //推力每次减小的步进值

	/* perform initial mix pass yielding unbounded outputs, ignore yaw */  //执行初始混合，忽略输出超过边界，忽略偏航轴
	for (unsigned i = 0; i < _rotor_count; i++) {  //对马达数量轮询，对每个马达进行计算
		float out = roll * _rotors[i].roll_scale +
			    pitch * _rotors[i].pitch_scale +
			    thrust;  //输出为除了yaw的值和

		out *= _rotors[i].out_scale;  //输出缩放

		/* calculate min and max output values */
		if (out < min_out) {  //计算最小和最大值，每个马达都计算，取其中最值
			min_out = out;
		}

		if (out > max_out) {
			max_out = out;
		}

		outputs[i] = out;
	}

	float boost = 0.0f;				// value added to demanded thrust (can also be negative)  增加到需要的推力，值同时可以为负
	float roll_pitch_scale = 1.0f;	// scale for demanded roll and pitch  缩放因子，对于俯仰和横滚轴

	if (min_out < 0.0f && max_out < 1.0f && -min_out <= 1.0f - max_out) {  //最大值在0,1范围内，最小值在-max_out,0范围内
		float max_thrust_diff = thrust * thrust_increase_factor - thrust;  //最大推力差值

		if (max_thrust_diff >= -min_out) { //如果在范围内
			boost = -min_out;  //推进

		} else {
			boost = max_thrust_diff;  //值较小
			roll_pitch_scale = (thrust + boost) / (thrust - min_out);  //缩放
		}

	} else if (max_out > 1.0f && min_out > 0.0f && min_out >= max_out - 1.0f) {
		float max_thrust_diff = thrust - thrust_decrease_factor * thrust;

		if (max_thrust_diff >= max_out - 1.0f) {
			boost = -(max_out - 1.0f);

		} else {
			boost = -max_thrust_diff;
			roll_pitch_scale = (1 - (thrust + boost)) / (max_out - thrust);
		}

	} else if (min_out < 0.0f && max_out < 1.0f && -min_out > 1.0f - max_out) {
		float max_thrust_diff = thrust * thrust_increase_factor - thrust;
		boost = constrain(-min_out - (1.0f - max_out) / 2.0f, 0.0f, max_thrust_diff);
		roll_pitch_scale = (thrust + boost) / (thrust - min_out);

	} else if (max_out > 1.0f && min_out > 0.0f && min_out < max_out - 1.0f) {
		float max_thrust_diff = thrust - thrust_decrease_factor * thrust;
		boost = constrain(-(max_out - 1.0f - min_out) / 2.0f, -max_thrust_diff, 0.0f);
		roll_pitch_scale = (1 - (thrust + boost)) / (max_out - thrust);

	} else if (min_out < 0.0f && max_out > 1.0f) {
		boost = constrain(-(max_out - 1.0f + min_out) / 2.0f, thrust_decrease_factor * thrust - thrust,
				  thrust_increase_factor * thrust - thrust);
		roll_pitch_scale = (thrust + boost) / (thrust - min_out);
	}

	// notify if saturation has occurred  如果发生饱和，通知
	if (min_out < 0.0f) {
		if (status_reg != NULL) {
			(*status_reg) |= PX4IO_P_STATUS_MIXER_LOWER_LIMIT; //混控到达低极限
		}
	}

	if (max_out > 0.0f) {
		if (status_reg != NULL) {
			(*status_reg) |= PX4IO_P_STATUS_MIXER_UPPER_LIMIT;  //混控到达高极限
		}
	}

	// mix again but now with thrust boost, scale roll/pitch and also add yaw  结合推力促进变量再次混合，缩放roll/pitch同事添加yaw
	for (unsigned i = 0; i < _rotor_count; i++) {  //对每个马达进行扫描
		float out = (roll * _rotors[i].roll_scale +
			     pitch * _rotors[i].pitch_scale) * roll_pitch_scale +
			    yaw * _rotors[i].yaw_scale +
			    thrust + boost;  //增加了yaw和推力促进

		out *= _rotors[i].out_scale;  //缩放输出

		// scale yaw if it violates limits. inform about yaw limit reached  如果超过限制，缩放yaw，并通知yaw到达极限
		if (out < 0.0f) { //如果输出小于0
			if (fabsf(_rotors[i].yaw_scale) <= FLT_EPSILON) {  //yaw缩放因子小于1E-5，最小能辨别的浮点数
				yaw = 0.0f;

			} else {
				yaw = -((roll * _rotors[i].roll_scale + pitch * _rotors[i].pitch_scale) *
					roll_pitch_scale + thrust + boost) / _rotors[i].yaw_scale;  //roll和pitch两次缩放，并加入推力和推力促进
			}

			if (status_reg != NULL) {
				(*status_reg) |= PX4IO_P_STATUS_MIXER_YAW_LIMIT;  //yaw到达极限标志
			}

		} else if (out > 1.0f) {  //输出大于1
			// allow to reduce thrust to get some yaw response  允许减小推力获得一些yaw的响应
			float thrust_reduction = fminf(0.15f, out - 1.0f);  //推力减小
			thrust -= thrust_reduction;  //推力减小

			if (fabsf(_rotors[i].yaw_scale) <= FLT_EPSILON) { //如果yaw缩放值小于1E-5
				yaw = 0.0f;

			} else {
				yaw = (1.0f - ((roll * _rotors[i].roll_scale + pitch * _rotors[i].pitch_scale) *
					       roll_pitch_scale + thrust + boost)) / _rotors[i].yaw_scale;
			}

			if (status_reg != NULL) {
				(*status_reg) |= PX4IO_P_STATUS_MIXER_YAW_LIMIT;  //通知yaw到达极限
			}
		}
	}

	/* add yaw and scale outputs to range idle_speed...1 */  //添加偏航和缩放输出
	for (unsigned i = 0; i < _rotor_count; i++) { //对每个马达进行扫描
		outputs[i] = (roll * _rotors[i].roll_scale +
			      pitch * _rotors[i].pitch_scale) * roll_pitch_scale +
			     yaw * _rotors[i].yaw_scale +
			     thrust + boost; //混合

		outputs[i] = constrain(_idle_speed + (outputs[i] * (1.0f - _idle_speed)), _idle_speed, 1.0f);  //限制
	}

	return _rotor_count; //返回马达数量
}

void
MultirotorMixer::groups_required(uint32_t &groups)
{
	/* XXX for now, hardcoded to indexes 0-3 in control group zero */  //硬件代码索引0-3到控制组0
	groups |= (1 << 0);
}

